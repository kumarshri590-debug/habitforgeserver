[{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\ai\\adjust-difficulty\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":115,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4005,4008],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4005,4008],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { callAI } from '@/lib/ai';\r\nimport { query } from '@/lib/db';\r\n\r\ninterface DifficultyAdjustment {\r\n    new_difficulty: number;\r\n    change: number;\r\n    explanation: string;\r\n    suggested_changes: {\r\n        duration?: string;\r\n        frequency?: string;\r\n    };\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n    try {\r\n        const body = await request.json();\r\n        const { habit_id, user_id } = body;\r\n\r\n        if (!habit_id || !user_id) {\r\n            return NextResponse.json(\r\n                { error: 'habit_id and user_id are required' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Get habit details\r\n        const habitResult = await query(\r\n            'SELECT * FROM habits WHERE id = $1 AND user_id = $2',\r\n            [habit_id, user_id]\r\n        );\r\n\r\n        if (habitResult.rows.length === 0) {\r\n            return NextResponse.json(\r\n                { error: 'Habit not found' },\r\n                { status: 404 }\r\n            );\r\n        }\r\n\r\n        const habit = habitResult.rows[0];\r\n\r\n        // Get recent completions (last 14 days)\r\n        const completionsResult = await query(\r\n            `SELECT * FROM habit_completions \r\n       WHERE habit_id = $1 \r\n       AND scheduled_for >= CURRENT_DATE - INTERVAL '14 days'\r\n       ORDER BY scheduled_for DESC`,\r\n            [habit_id]\r\n        );\r\n\r\n        const completions = completionsResult.rows;\r\n        const last7Days = completions.slice(0, 7);\r\n        const completionRate7d = last7Days.filter(c => c.completed_at).length / 7;\r\n        const completionRate14d = completions.filter(c => c.completed_at).length / 14;\r\n        const struggledCount = last7Days.filter(c => c.mood === 'struggled').length;\r\n        const currentStreak = completions[0]?.streak_count || 0;\r\n\r\n        // Build AI prompt\r\n        const prompt = `Analyze this habit completion history and recommend a difficulty adjustment.\r\n\r\nHABIT: ${habit.name}\r\nCURRENT DIFFICULTY: ${habit.difficulty_level} (1-10 scale)\r\nCOMPLETION RATE (7 days): ${(completionRate7d * 100).toFixed(0)}%\r\nCOMPLETION RATE (14 days): ${(completionRate14d * 100).toFixed(0)}%\r\nSTRUGGLED COUNT (last 7 days): ${struggledCount}\r\nCURRENT STREAK: ${currentStreak} days\r\n\r\nADJUSTMENT RULES:\r\n- If completion rate < 50% for 7 days: reduce difficulty by 1-2 levels\r\n- If completion rate > 85% for 14 days AND streak >= 7: increase difficulty by 1 level\r\n- If user reported \"struggled\" 3+ times: reduce difficulty by 1 level\r\n- Never increase difficulty if streak < 7 days\r\n- Max change: Â±2 levels per adjustment\r\n- New difficulty must be between 1-10\r\n\r\nReturn JSON with this exact structure:\r\n{\r\n  \"new_difficulty\": <number 1-10>,\r\n  \"change\": <number (positive or negative)>,\r\n  \"explanation\": \"<one supportive sentence>\",\r\n  \"suggested_changes\": {\r\n    \"duration\": \"<specific change or null>\",\r\n    \"frequency\": \"<specific change or null>\"\r\n  }\r\n}`;\r\n\r\n        const adjustment = await callAI<DifficultyAdjustment>(prompt);\r\n\r\n        // Validate adjustment\r\n        if (adjustment.new_difficulty < 1 || adjustment.new_difficulty > 10) {\r\n            throw new Error('Invalid difficulty level from AI');\r\n        }\r\n\r\n        // Log AI decision\r\n        await query(\r\n            `INSERT INTO ai_decisions (\r\n        user_id, habit_id, decision_type, input_data, output_data, explanation\r\n      ) VALUES ($1, $2, $3, $4, $5, $6)`,\r\n            [\r\n                user_id,\r\n                habit_id,\r\n                'difficulty_adjustment',\r\n                JSON.stringify({ completionRate7d, completionRate14d, struggledCount, currentStreak }),\r\n                JSON.stringify(adjustment),\r\n                adjustment.explanation,\r\n            ]\r\n        );\r\n\r\n        return NextResponse.json({\r\n            adjustment: {\r\n                ...adjustment,\r\n                should_apply: Math.abs(adjustment.change) > 0,\r\n            },\r\n        });\r\n    } catch (error: any) {\r\n        console.error('Error adjusting difficulty:', error);\r\n        return NextResponse.json(\r\n            { error: 'Failed to adjust difficulty', details: error.message },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\ai\\adjust\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextRequest' is defined but never used.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextResponse' is defined but never used.","line":1,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[482,485],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[482,485],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { adjustDifficulty } from '@/src/services/aiService';\r\nimport { withAuth, errorResponse, successResponse } from '@/src/lib/middleware';\r\n\r\nexport const POST = withAuth(async (req) => {\r\n    try {\r\n        const userId = req.userId!;\r\n        const body = await req.json();\r\n\r\n        const result = await adjustDifficulty(userId, body);\r\n\r\n        return successResponse({ adjustment: result });\r\n    } catch (error: any) {\r\n        return errorResponse(error.message || 'Failed to adjust difficulty', 400);\r\n    }\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\ai\\generate-fallback\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":106,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3457,3460],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3457,3460],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { callAI } from '@/lib/ai';\r\nimport { query } from '@/lib/db';\r\n\r\ninterface FallbackHabit {\r\n    name: string;\r\n    difficulty: number;\r\n    explanation: string;\r\n}\r\n\r\ninterface FallbackResponse {\r\n    fallback_habits: FallbackHabit[];\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n    try {\r\n        const body = await request.json();\r\n        const { habit_id, user_id, context } = body;\r\n\r\n        if (!habit_id || !user_id) {\r\n            return NextResponse.json(\r\n                { error: 'habit_id and user_id are required' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Get habit details\r\n        const habitResult = await query(\r\n            'SELECT * FROM habits WHERE id = $1 AND user_id = $2',\r\n            [habit_id, user_id]\r\n        );\r\n\r\n        if (habitResult.rows.length === 0) {\r\n            return NextResponse.json(\r\n                { error: 'Habit not found' },\r\n                { status: 404 }\r\n            );\r\n        }\r\n\r\n        const habit = habitResult.rows[0];\r\n\r\n        // Build AI prompt\r\n        const prompt = `Generate 2 easier alternative habits for a user who's struggling.\r\n\r\nORIGINAL HABIT: ${habit.name} (difficulty ${habit.difficulty_level})\r\nGOAL: ${habit.goal || 'Not specified'}\r\nCONTEXT: ${context || 'User is having difficulty maintaining consistency'}\r\n\r\nREQUIREMENTS:\r\n- Fallback 1: 50% easier (difficulty should be ${Math.max(1, habit.difficulty_level - 3)} to ${Math.max(1, habit.difficulty_level - 4)})\r\n- Fallback 2: 75% easier (difficulty should be ${Math.max(1, habit.difficulty_level - 5)} to ${Math.max(1, habit.difficulty_level - 6)})\r\n- Keep the core intent of the original habit\r\n- Make them achievable in < 5 minutes\r\n- Use encouraging language\r\n\r\nReturn JSON with this exact structure:\r\n{\r\n  \"fallback_habits\": [\r\n    {\r\n      \"name\": \"<habit name>\",\r\n      \"difficulty\": <number 1-10>,\r\n      \"explanation\": \"<why this helps>\"\r\n    },\r\n    {\r\n      \"name\": \"<habit name>\",\r\n      \"difficulty\": <number 1-10>,\r\n      \"explanation\": \"<why this helps>\"\r\n    }\r\n  ]\r\n}`;\r\n\r\n        const response = await callAI<FallbackResponse>(prompt);\r\n\r\n        // Save fallback habits to database\r\n        for (const fallback of response.fallback_habits) {\r\n            await query(\r\n                `INSERT INTO fallback_habits (\r\n          parent_habit_id, name, description, difficulty_level, generation_context\r\n        ) VALUES ($1, $2, $3, $4, $5)`,\r\n                [\r\n                    habit_id,\r\n                    fallback.name,\r\n                    fallback.explanation,\r\n                    fallback.difficulty,\r\n                    JSON.stringify({ context, original_difficulty: habit.difficulty_level }),\r\n                ]\r\n            );\r\n        }\r\n\r\n        // Log AI decision\r\n        await query(\r\n            `INSERT INTO ai_decisions (\r\n        user_id, habit_id, decision_type, input_data, output_data, explanation\r\n      ) VALUES ($1, $2, $3, $4, $5, $6)`,\r\n            [\r\n                user_id,\r\n                habit_id,\r\n                'fallback_generation',\r\n                JSON.stringify({ habit_name: habit.name, difficulty: habit.difficulty_level, context }),\r\n                JSON.stringify(response),\r\n                'Generated fallback habits for struggling user',\r\n            ]\r\n        );\r\n\r\n        return NextResponse.json(response);\r\n    } catch (error: any) {\r\n        console.error('Error generating fallback:', error);\r\n        return NextResponse.json(\r\n            { error: 'Failed to generate fallback habits', details: error.message },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\ai\\generate-plan\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextRequest' is defined but never used.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextResponse' is defined but never used.","line":1,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[468,471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[468,471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { generateHabitPlan } from '@/src/services/aiService';\r\nimport { withAuth, errorResponse, successResponse } from '@/src/lib/middleware';\r\n\r\nexport const POST = withAuth(async (req) => {\r\n    try {\r\n        const userId = req.userId!;\r\n        const body = await req.json();\r\n\r\n        const plan = await generateHabitPlan(userId, body);\r\n\r\n        return successResponse({ plan });\r\n    } catch (error: any) {\r\n        return errorResponse(error.message || 'Failed to generate plan', 400);\r\n    }\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\ai\\generate-reminder\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1471,1474],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1471,1474],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { callAI } from '@/lib/ai';\r\n\r\ninterface ReminderResponse {\r\n    message: string;\r\n    tone: string;\r\n    explanation: string;\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n    try {\r\n        const body = await request.json();\r\n        const {\r\n            habit_name,\r\n            time_of_day = 'morning',\r\n            recent_completion_rate = 0.7,\r\n            tone_preference = 'supportive'\r\n        } = body;\r\n\r\n        if (!habit_name) {\r\n            return NextResponse.json(\r\n                { error: 'habit_name is required' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Build AI prompt\r\n        const prompt = `Generate a reminder message for this habit.\r\n\r\nHABIT: ${habit_name}\r\nTIME: ${time_of_day}\r\nCOMPLETION RATE (7d): ${(recent_completion_rate * 100).toFixed(0)}%\r\nTONE: ${tone_preference}\r\n\r\nRULES:\r\n- If completion_rate > 0.7: motivational, celebrate momentum\r\n- If completion_rate 0.4-0.7: supportive, reduce pressure\r\n- If completion_rate < 0.4: gentle, emphasize small wins\r\n- Max 15 words\r\n- No guilt or \"you should\" language\r\n- Be specific to the habit\r\n\r\nReturn JSON with this exact structure:\r\n{\r\n  \"message\": \"<reminder text>\",\r\n  \"tone\": \"<tone used>\",\r\n  \"explanation\": \"<why this message>\"\r\n}`;\r\n\r\n        const reminder = await callAI<ReminderResponse>(prompt);\r\n\r\n        return NextResponse.json({ reminder });\r\n    } catch (error: any) {\r\n        console.error('Error generating reminder:', error);\r\n        return NextResponse.json(\r\n            { error: 'Failed to generate reminder', details: error.message },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\auth\\login\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextResponse' is defined but never used.","line":1,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[390,393],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[390,393],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { login } from '@/src/services/authService';\r\nimport { errorResponse, successResponse } from '@/src/lib/middleware';\r\n\r\nexport async function POST(req: NextRequest) {\r\n    try {\r\n        const body = await req.json();\r\n        const result = await login(body);\r\n\r\n        return successResponse(result);\r\n    } catch (error: any) {\r\n        return errorResponse(error.message || 'Login failed', 401);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\auth\\profile\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextRequest' is defined but never used.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextResponse' is defined but never used.","line":1,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[417,420],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[417,420],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { getUserProfile } from '@/src/services/authService';\r\nimport { withAuth, errorResponse, successResponse } from '@/src/lib/middleware';\r\n\r\nexport const GET = withAuth(async (req) => {\r\n    try {\r\n        const userId = req.userId!;\r\n        const profile = await getUserProfile(userId);\r\n\r\n        return successResponse(profile);\r\n    } catch (error: any) {\r\n        return errorResponse(error.message || 'Failed to get profile', 400);\r\n    }\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\auth\\signup\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextResponse' is defined but never used.","line":1,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[397,400],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[397,400],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { signup } from '@/src/services/authService';\r\nimport { errorResponse, successResponse } from '@/src/lib/middleware';\r\n\r\nexport async function POST(req: NextRequest) {\r\n    try {\r\n        const body = await req.json();\r\n        const result = await signup(body);\r\n\r\n        return successResponse(result, 201);\r\n    } catch (error: any) {\r\n        return errorResponse(error.message || 'Signup failed', 400);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\habits\\[id]\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextRequest' is defined but never used.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextResponse' is defined but never used.","line":1,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[527,530],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[527,530],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":27,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[970,973],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[970,973],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":40,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1365,1368],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1365,1368],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { getHabitById, updateHabit, deleteHabit } from '@/src/services/habitService';\r\nimport { withAuth, errorResponse, successResponse } from '@/src/lib/middleware';\r\n\r\nexport const GET = withAuth(async (req, { params }: { params: { id: string } }) => {\r\n    try {\r\n        const userId = req.userId!;\r\n        const habitId = params.id;\r\n\r\n        const habit = await getHabitById(userId, habitId);\r\n\r\n        return successResponse({ habit });\r\n    } catch (error: any) {\r\n        return errorResponse(error.message || 'Failed to get habit', 404);\r\n    }\r\n});\r\n\r\nexport const PATCH = withAuth(async (req, { params }: { params: { id: string } }) => {\r\n    try {\r\n        const userId = req.userId!;\r\n        const habitId = params.id;\r\n        const body = await req.json();\r\n\r\n        const habit = await updateHabit(userId, habitId, body);\r\n\r\n        return successResponse({ habit });\r\n    } catch (error: any) {\r\n        return errorResponse(error.message || 'Failed to update habit', 400);\r\n    }\r\n});\r\n\r\nexport const DELETE = withAuth(async (req, { params }: { params: { id: string } }) => {\r\n    try {\r\n        const userId = req.userId!;\r\n        const habitId = params.id;\r\n\r\n        await deleteHabit(userId, habitId);\r\n\r\n        return successResponse({ success: true });\r\n    } catch (error: any) {\r\n        return errorResponse(error.message || 'Failed to delete habit', 400);\r\n    }\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\habits\\[id]\\stats\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextRequest' is defined but never used.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextResponse' is defined but never used.","line":1,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[627,630],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[627,630],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { getHabitStats } from '@/src/services/habitService';\r\nimport { withAuth, errorResponse, successResponse } from '@/src/lib/middleware';\r\n\r\nexport const GET = withAuth(async (req, { params }: { params: { id: string } }) => {\r\n    try {\r\n        const userId = req.userId!;\r\n        const habitId = params.id;\r\n        const { searchParams } = new URL(req.url);\r\n        const days = parseInt(searchParams.get('days') || '30');\r\n\r\n        const stats = await getHabitStats(userId, habitId, days);\r\n\r\n        return successResponse({ stats });\r\n    } catch (error: any) {\r\n        return errorResponse(error.message || 'Failed to get stats', 400);\r\n    }\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\habits\\[id]\\track\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextRequest' is defined but never used.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextResponse' is defined but never used.","line":1,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[561,564],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[561,564],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { logHabitCompletion } from '@/src/services/habitService';\r\nimport { withAuth, errorResponse, successResponse } from '@/src/lib/middleware';\r\n\r\nexport const POST = withAuth(async (req, { params }: { params: { id: string } }) => {\r\n    try {\r\n        const userId = req.userId!;\r\n        const habitId = params.id;\r\n        const body = await req.json();\r\n\r\n        const log = await logHabitCompletion(userId, habitId, body);\r\n\r\n        return successResponse({ log }, 201);\r\n    } catch (error: any) {\r\n        return errorResponse(error.message || 'Failed to log completion', 400);\r\n    }\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\habits\\create\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1445,1448],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1445,1448],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { query } from '@/lib/db';\r\n\r\nexport async function POST(request: NextRequest) {\r\n    try {\r\n        const body = await request.json();\r\n        const {\r\n            user_id,\r\n            name,\r\n            goal,\r\n            frequency_type = 'daily',\r\n            frequency_target = 1,\r\n            initial_difficulty = 3,\r\n            is_ai_managed = true\r\n        } = body;\r\n\r\n        // Validation\r\n        if (!user_id || !name) {\r\n            return NextResponse.json(\r\n                { error: 'user_id and name are required' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        if (initial_difficulty < 1 || initial_difficulty > 10) {\r\n            return NextResponse.json(\r\n                { error: 'initial_difficulty must be between 1 and 10' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const result = await query(\r\n            `INSERT INTO habits (\r\n        user_id, name, goal, frequency_type, frequency_target, \r\n        difficulty_level, initial_difficulty, is_ai_managed\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\r\n      RETURNING *`,\r\n            [user_id, name, goal, frequency_type, frequency_target, initial_difficulty, initial_difficulty, is_ai_managed]\r\n        );\r\n\r\n        return NextResponse.json({\r\n            success: true,\r\n            habit: result.rows[0],\r\n        });\r\n    } catch (error: any) {\r\n        console.error('Error creating habit:', error);\r\n        return NextResponse.json(\r\n            { error: 'Failed to create habit', details: error.message },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\habits\\list\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":46,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1626,1629],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1626,1629],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { query } from '@/lib/db';\r\n\r\nexport async function GET(request: NextRequest) {\r\n    try {\r\n        const { searchParams } = new URL(request.url);\r\n        const userId = searchParams.get('user_id');\r\n        const status = searchParams.get('status') || 'active';\r\n\r\n        if (!userId) {\r\n            return NextResponse.json(\r\n                { error: 'user_id is required' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Get habits with completion stats\r\n        const result = await query(\r\n            `SELECT \r\n        h.*,\r\n        COUNT(DISTINCT hc.id) FILTER (WHERE hc.scheduled_for >= CURRENT_DATE - INTERVAL '7 days') as completions_7d,\r\n        COUNT(DISTINCT hc.id) FILTER (WHERE hc.scheduled_for >= CURRENT_DATE - INTERVAL '30 days') as completions_30d,\r\n        (\r\n          SELECT streak_count \r\n          FROM habit_completions \r\n          WHERE habit_id = h.id \r\n          ORDER BY completed_at DESC \r\n          LIMIT 1\r\n        ) as current_streak\r\n      FROM habits h\r\n      LEFT JOIN habit_completions hc ON h.id = hc.habit_id\r\n      WHERE h.user_id = $1 AND h.status = $2\r\n      GROUP BY h.id\r\n      ORDER BY h.created_at DESC`,\r\n            [userId, status]\r\n        );\r\n\r\n        const habits = result.rows.map(habit => ({\r\n            ...habit,\r\n            current_streak: habit.current_streak || 0,\r\n            completion_rate_7d: habit.completions_7d / 7,\r\n            completion_rate_30d: habit.completions_30d / 30,\r\n        }));\r\n\r\n        return NextResponse.json({ habits });\r\n    } catch (error: any) {\r\n        console.error('Error fetching habits:', error);\r\n        return NextResponse.json(\r\n            { error: 'Failed to fetch habits', details: error.message },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\habits\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextRequest' is defined but never used.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextResponse' is defined but never used.","line":1,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[549,552],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[549,552],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":27,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[912,915],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[912,915],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { createHabit, getHabits } from '@/src/services/habitService';\r\nimport { withAuth, errorResponse, successResponse } from '@/src/lib/middleware';\r\n\r\nexport const GET = withAuth(async (req) => {\r\n    try {\r\n        const userId = req.userId!;\r\n        const { searchParams } = new URL(req.url);\r\n        const status = searchParams.get('status') || 'active';\r\n\r\n        const habits = await getHabits(userId, status);\r\n\r\n        return successResponse({ habits });\r\n    } catch (error: any) {\r\n        return errorResponse(error.message || 'Failed to get habits', 400);\r\n    }\r\n});\r\n\r\nexport const POST = withAuth(async (req) => {\r\n    try {\r\n        const userId = req.userId!;\r\n        const body = await req.json();\r\n\r\n        const habit = await createHabit(userId, body);\r\n\r\n        return successResponse({ habit }, 201);\r\n    } catch (error: any) {\r\n        return errorResponse(error.message || 'Failed to create habit', 400);\r\n    }\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\sync\\pull\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextRequest' is defined but never used.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextResponse' is defined but never used.","line":1,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pushChanges' is defined but never used.","line":2,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":34},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[554,557],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[554,557],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { pullChanges, pushChanges } from '@/src/services/syncService';\r\nimport { withAuth, errorResponse, successResponse } from '@/src/lib/middleware';\r\n\r\nexport const GET = withAuth(async (req) => {\r\n    try {\r\n        const userId = req.userId!;\r\n        const { searchParams } = new URL(req.url);\r\n        const lastSync = searchParams.get('since');\r\n\r\n        const changes = await pullChanges(userId, lastSync || undefined);\r\n\r\n        return successResponse(changes);\r\n    } catch (error: any) {\r\n        return errorResponse(error.message || 'Failed to pull changes', 400);\r\n    }\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\sync\\push\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextRequest' is defined but never used.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NextResponse' is defined but never used.","line":1,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[496,499],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[496,499],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { pushChanges } from '@/src/services/syncService';\r\nimport { withAuth, errorResponse, successResponse } from '@/src/lib/middleware';\r\n\r\nexport const POST = withAuth(async (req) => {\r\n    try {\r\n        const userId = req.userId!;\r\n        const body = await req.json();\r\n        const { changes } = body;\r\n\r\n        const result = await pushChanges(userId, changes);\r\n\r\n        return successResponse(result);\r\n    } catch (error: any) {\r\n        return errorResponse(error.message || 'Failed to push changes', 400);\r\n    }\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\tracking\\complete\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":5,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[171,174],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[171,174],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1249,1252],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1249,1252],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":134,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4420,4423],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4420,4423],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { query } from '@/lib/db';\r\n\r\n// Calculate streak from completions\r\nfunction calculateStreak(completions: any[]): number {\r\n    if (completions.length === 0) return 0;\r\n\r\n    const sorted = completions.sort((a, b) =>\r\n        new Date(b.scheduled_for).getTime() - new Date(a.scheduled_for).getTime()\r\n    );\r\n\r\n    let streak = 0;\r\n    const today = new Date();\r\n    today.setHours(0, 0, 0, 0);\r\n\r\n    for (let i = 0; i < sorted.length; i++) {\r\n        const completionDate = new Date(sorted[i].scheduled_for);\r\n        completionDate.setHours(0, 0, 0, 0);\r\n\r\n        const expectedDate = new Date(today);\r\n        expectedDate.setDate(today.getDate() - streak);\r\n\r\n        const daysDiff = Math.floor(\r\n            (expectedDate.getTime() - completionDate.getTime()) / (1000 * 60 * 60 * 24)\r\n        );\r\n\r\n        if (daysDiff === 0) {\r\n            streak++;\r\n        } else if (daysDiff === 1) {\r\n            // Grace day - allow 1 day gap\r\n            streak++;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return streak;\r\n}\r\n\r\n// Check if this is a recovery completion (after missing yesterday)\r\nfunction isRecoveryCompletion(habitId: string, recentCompletions: any[]): boolean {\r\n    const yesterday = new Date();\r\n    yesterday.setDate(yesterday.getDate() - 1);\r\n    yesterday.setHours(0, 0, 0, 0);\r\n\r\n    const yesterdayCompletion = recentCompletions.find(c => {\r\n        const date = new Date(c.scheduled_for);\r\n        date.setHours(0, 0, 0, 0);\r\n        return date.getTime() === yesterday.getTime();\r\n    });\r\n\r\n    return !yesterdayCompletion;\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n    try {\r\n        const body = await request.json();\r\n        const {\r\n            habit_id,\r\n            user_id,\r\n            scheduled_for,\r\n            completion_time_seconds,\r\n            mood,\r\n            notes\r\n        } = body;\r\n\r\n        if (!habit_id || !user_id || !scheduled_for) {\r\n            return NextResponse.json(\r\n                { error: 'habit_id, user_id, and scheduled_for are required' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Get recent completions to calculate streak\r\n        const recentResult = await query(\r\n            `SELECT * FROM habit_completions \r\n       WHERE habit_id = $1 \r\n       ORDER BY scheduled_for DESC \r\n       LIMIT 30`,\r\n            [habit_id]\r\n        );\r\n\r\n        const recentCompletions = recentResult.rows;\r\n        const newStreak = calculateStreak(recentCompletions) + 1;\r\n        const isRecovery = isRecoveryCompletion(habit_id, recentCompletions);\r\n\r\n        // Insert completion\r\n        const result = await query(\r\n            `INSERT INTO habit_completions (\r\n        habit_id, user_id, scheduled_for, completion_time_seconds, \r\n        mood, notes, streak_count, is_recovery\r\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\r\n      RETURNING *`,\r\n            [habit_id, user_id, scheduled_for, completion_time_seconds, mood, notes, newStreak, isRecovery]\r\n        );\r\n\r\n        // Get habit to check if AI adjustment is needed\r\n        const habitResult = await query(\r\n            'SELECT * FROM habits WHERE id = $1',\r\n            [habit_id]\r\n        );\r\n\r\n        const habit = habitResult.rows[0];\r\n        let aiFeedback = null;\r\n\r\n        if (habit.is_ai_managed) {\r\n            // Simple AI feedback logic\r\n            const completionRate = recentCompletions.length / 7;\r\n\r\n            if (newStreak >= 7 && completionRate > 0.85) {\r\n                aiFeedback = {\r\n                    message: \"Great job maintaining your streak! You're building real momentum.\",\r\n                    should_adjust_difficulty: true,\r\n                    suggested_adjustment: 1,\r\n                };\r\n            } else if (isRecovery) {\r\n                aiFeedback = {\r\n                    message: \"Welcome back! Every restart is a step forward.\",\r\n                    should_adjust_difficulty: false,\r\n                };\r\n            } else {\r\n                aiFeedback = {\r\n                    message: `Day ${newStreak} complete! Keep going.`,\r\n                    should_adjust_difficulty: false,\r\n                };\r\n            }\r\n        }\r\n\r\n        return NextResponse.json({\r\n            success: true,\r\n            completion: result.rows[0],\r\n            ai_feedback: aiFeedback,\r\n        });\r\n    } catch (error: any) {\r\n        console.error('Error completing habit:', error);\r\n        return NextResponse.json(\r\n            { error: 'Failed to complete habit', details: error.message },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\api\\tracking\\history\\[habitId]\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2006,2009],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2006,2009],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { query } from '@/lib/db';\r\n\r\nexport async function GET(\r\n    request: NextRequest,\r\n    { params }: { params: Promise<{ habitId: string }> }\r\n) {\r\n    try {\r\n        const { habitId } = await params;\r\n        const { searchParams } = new URL(request.url);\r\n        const days = parseInt(searchParams.get('days') || '30');\r\n\r\n        // Get completions\r\n        const completionsResult = await query(\r\n            `SELECT * FROM habit_completions \r\n       WHERE habit_id = $1 \r\n       AND scheduled_for >= CURRENT_DATE - INTERVAL '${days} days'\r\n       ORDER BY scheduled_for DESC`,\r\n            [habitId]\r\n        );\r\n\r\n        const completions = completionsResult.rows;\r\n\r\n        // Calculate stats\r\n        const totalCompletions = completions.length;\r\n        const completionRate = totalCompletions / days;\r\n        const currentStreak = completions[0]?.streak_count || 0;\r\n        const longestStreak = Math.max(...completions.map(c => c.streak_count), 0);\r\n        const averageCompletionTime = completions.length > 0\r\n            ? completions.reduce((sum, c) => sum + (c.completion_time_seconds || 0), 0) / completions.length\r\n            : 0;\r\n\r\n        // Format completions for calendar view\r\n        const formattedCompletions = completions.map(c => ({\r\n            date: c.scheduled_for,\r\n            completed: true,\r\n            mood: c.mood,\r\n            streak_count: c.streak_count,\r\n            completion_time_seconds: c.completion_time_seconds,\r\n        }));\r\n\r\n        return NextResponse.json({\r\n            completions: formattedCompletions,\r\n            stats: {\r\n                total_completions: totalCompletions,\r\n                completion_rate: parseFloat(completionRate.toFixed(2)),\r\n                current_streak: currentStreak,\r\n                longest_streak: longestStreak,\r\n                average_completion_time: Math.round(averageCompletionTime),\r\n            },\r\n        });\r\n    } catch (error: any) {\r\n        console.error('Error fetching history:', error);\r\n        return NextResponse.json(\r\n            { error: 'Failed to fetch history', details: error.message },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\app\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\lib\\ai.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'schema' is defined but never used.","line":32,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":11},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":32,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[832,835],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[832,835],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import OpenAI from 'openai';\r\n\r\nconst openai = new OpenAI({\r\n    apiKey: process.env.OPENAI_API_KEY,\r\n});\r\n\r\nexport const AI_CONFIG = {\r\n    model: 'gpt-4o-mini',\r\n    temperature: 0.3,\r\n    maxTokens: 1000,\r\n};\r\n\r\nexport const SYSTEM_PROMPT = `You are HabitForge AI, a supportive habit-building assistant.\r\n\r\nRULES:\r\n1. Always return valid JSON matching the specified schema\r\n2. Never use guilt, shame, or pressure-based language\r\n3. Prioritize consistency over intensity\r\n4. Adjust gradually (max 2 difficulty levels at a time)\r\n5. Explain decisions in one supportive sentence\r\n6. Respect user autonomy - you suggest, they decide\r\n\r\nTONE:\r\n- Supportive, not pushy\r\n- Encouraging, not patronizing\r\n- Data-driven, not judgmental`;\r\n\r\nexport default openai;\r\n\r\nexport async function callAI<T>(\r\n    userPrompt: string,\r\n    schema?: any\r\n): Promise<T> {\r\n    try {\r\n        const response = await openai.chat.completions.create({\r\n            model: AI_CONFIG.model,\r\n            temperature: AI_CONFIG.temperature,\r\n            max_tokens: AI_CONFIG.maxTokens,\r\n            messages: [\r\n                { role: 'system', content: SYSTEM_PROMPT },\r\n                { role: 'user', content: userPrompt },\r\n            ],\r\n            response_format: { type: 'json_object' },\r\n        });\r\n\r\n        const content = response.choices[0].message.content;\r\n        if (!content) {\r\n            throw new Error('No response from AI');\r\n        }\r\n\r\n        return JSON.parse(content) as T;\r\n    } catch (error) {\r\n        console.error('AI call failed:', error);\r\n        throw error;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\lib\\db.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[271,274],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[271,274],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Pool } from 'pg';\r\n\r\nconst pool = new Pool({\r\n  connectionString: process.env.DATABASE_URL,\r\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\r\n});\r\n\r\nexport default pool;\r\n\r\nexport async function query(text: string, params?: any[]) {\r\n  const start = Date.now();\r\n  const res = await pool.query(text, params);\r\n  const duration = Date.now() - start;\r\n  \r\n  if (process.env.NODE_ENV === 'development') {\r\n    console.log('Executed query', { text, duration, rows: res.rowCount });\r\n  }\r\n  \r\n  return res;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\next.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\postcss.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\src\\lib\\auth.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":27,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import bcrypt from 'bcryptjs';\r\nimport jwt from 'jsonwebtoken';\r\n\r\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';\r\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n\r\nexport interface JWTPayload {\r\n    userId: string;\r\n    email: string;\r\n}\r\n\r\nexport async function hashPassword(password: string): Promise<string> {\r\n    return bcrypt.hash(password, 12);\r\n}\r\n\r\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\r\n    return bcrypt.compare(password, hash);\r\n}\r\n\r\nexport function generateToken(payload: JWTPayload): string {\r\n    return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n}\r\n\r\nexport function verifyToken(token: string): JWTPayload {\r\n    try {\r\n        return jwt.verify(token, JWT_SECRET) as JWTPayload;\r\n    } catch (error) {\r\n        throw new Error('Invalid or expired token');\r\n    }\r\n}\r\n\r\nexport function extractTokenFromHeader(authHeader: string | null): string | null {\r\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\r\n        return null;\r\n    }\r\n    return authHeader.substring(7);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\src\\lib\\middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":32,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1414,1417],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1414,1417],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { verifyToken, extractTokenFromHeader } from './auth';\r\n\r\nexport interface AuthenticatedRequest extends NextRequest {\r\n    userId?: string;\r\n    email?: string;\r\n}\r\n\r\nexport function withAuth(\r\n    handler: (req: AuthenticatedRequest) => Promise<NextResponse>\r\n) {\r\n    return async (req: NextRequest) => {\r\n        try {\r\n            const authHeader = req.headers.get('authorization');\r\n            const token = extractTokenFromHeader(authHeader);\r\n\r\n            if (!token) {\r\n                return NextResponse.json(\r\n                    { error: 'Authentication required' },\r\n                    { status: 401 }\r\n                );\r\n            }\r\n\r\n            const payload = verifyToken(token);\r\n\r\n            // Attach user info to request\r\n            const authenticatedReq = req as AuthenticatedRequest;\r\n            authenticatedReq.userId = payload.userId;\r\n            authenticatedReq.email = payload.email;\r\n\r\n            return handler(authenticatedReq);\r\n        } catch (error) {\r\n            return NextResponse.json(\r\n                { error: 'Invalid or expired token' },\r\n                { status: 401 }\r\n            );\r\n        }\r\n    };\r\n}\r\n\r\nexport function errorResponse(message: string, status: number = 400) {\r\n    return NextResponse.json({ error: message }, { status });\r\n}\r\n\r\nexport function successResponse(data: any, status: number = 200) {\r\n    return NextResponse.json(data, { status });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\src\\lib\\prisma.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\src\\lib\\queue.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Worker' is defined but never used.","line":1,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Queue, Worker, QueueEvents } from 'bullmq';\r\nimport Redis from 'ioredis';\r\n\r\nconst connection = new Redis(process.env.REDIS_URL || 'redis://localhost:6379', {\r\n    maxRetriesPerRequest: null,\r\n});\r\n\r\n// Job Types\r\nexport const JOB_TYPES = {\r\n    SEND_REMINDERS: 'send_reminders',\r\n    CALCULATE_STREAKS: 'calculate_streaks',\r\n    DETECT_BURNOUT: 'detect_burnout',\r\n    GENERATE_INSIGHTS: 'generate_insights',\r\n    ADJUST_DIFFICULTY: 'adjust_difficulty',\r\n    SYNC_OFFLINE_DATA: 'sync_offline_data',\r\n    PREDICT_INTERVENTION: 'predict_intervention',\r\n} as const;\r\n\r\n// Create queues\r\nexport const queues = {\r\n    reminders: new Queue('reminders', { connection }),\r\n    streaks: new Queue('streaks', { connection }),\r\n    burnout: new Queue('burnout', { connection }),\r\n    insights: new Queue('insights', { connection }),\r\n    ai: new Queue('ai', { connection }),\r\n    sync: new Queue('sync', { connection }),\r\n};\r\n\r\n// Queue events for monitoring\r\nexport const queueEvents = {\r\n    reminders: new QueueEvents('reminders', { connection }),\r\n    streaks: new QueueEvents('streaks', { connection }),\r\n    burnout: new QueueEvents('burnout', { connection }),\r\n    insights: new QueueEvents('insights', { connection }),\r\n    ai: new QueueEvents('ai', { connection }),\r\n    sync: new QueueEvents('sync', { connection }),\r\n};\r\n\r\nexport { connection };\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\src\\services\\aiService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":105,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2792,2795],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2792,2795],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":113,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3025,3028],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3025,3028],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'model' is defined but never used.","line":136,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":136,"endColumn":45},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":146,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":146,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4023,4026],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4023,4026],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":147,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4045,4048],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4045,4048],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":361,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":361,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10580,10583],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10580,10583],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":362,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":362,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10626,10629],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10626,10629],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":364,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":364,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10763,10766],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10763,10766],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import OpenAI from 'openai';\r\nimport prisma from './prisma';\r\nimport { connection as redis } from './queue';\r\n\r\nconst openai = new OpenAI({\r\n    apiKey: process.env.OPENAI_API_KEY,\r\n});\r\n\r\nconst MODEL = 'gpt-4o-mini';\r\nconst CACHE_TTL = 24 * 60 * 60; // 24 hours in seconds\r\nconst MAX_REQUESTS_PER_DAY = 50;\r\n\r\n// ============================================\r\n// TYPES\r\n// ============================================\r\n\r\nexport interface GeneratePlanInput {\r\n    goal: string;\r\n    userContext: {\r\n        experienceLevel?: string;\r\n        availableTime?: string;\r\n        constraints?: string[];\r\n    };\r\n    coachingTone: string;\r\n}\r\n\r\nexport interface GeneratePlanOutput {\r\n    habitTitle: string;\r\n    microSteps: Array<{ step: string; duration: string }>;\r\n    estimatedDifficulty: number;\r\n    rationale: string;\r\n    suggestedFrequency: string;\r\n    optimalTime: string;\r\n}\r\n\r\nexport interface AdjustDifficultyInput {\r\n    habitId: string;\r\n    currentDifficulty: number;\r\n    recentPerformance: {\r\n        completionRate7d: number;\r\n        completionRate30d: number;\r\n        consecutiveMisses: number;\r\n        userFeedback: Array<{ date: string; feltTooHard?: boolean; feltTooEasy?: boolean }>;\r\n    };\r\n    context?: {\r\n        energyLevels?: number[];\r\n        timeAvailable?: number[];\r\n    };\r\n}\r\n\r\nexport interface AdjustDifficultyOutput {\r\n    newDifficulty: number;\r\n    adjustmentReason: string;\r\n    explanation: string;\r\n    recommendedChanges?: {\r\n        microSteps?: Array<{ step: string; duration: string }>;\r\n    };\r\n    confidence: number;\r\n}\r\n\r\nexport interface BurnoutAnalysisInput {\r\n    userId: string;\r\n    habitsSummary: Array<{\r\n        habitId: string;\r\n        title: string;\r\n        completionRate30d: number;\r\n        completionRate7d: number;\r\n        difficulty: number;\r\n        recentFeedback?: string[];\r\n    }>;\r\n    overallMetrics: {\r\n        totalActiveHabits: number;\r\n        avgCompletionRate: number;\r\n        trend: string;\r\n    };\r\n}\r\n\r\nexport interface BurnoutAnalysisOutput {\r\n    burnoutDetected: boolean;\r\n    severity: 'none' | 'low' | 'medium' | 'high';\r\n    primaryCauses: string[];\r\n    suggestedActions: Array<{\r\n        action: string;\r\n        habitIds?: string[];\r\n        newDifficulty?: number;\r\n        explanation: string;\r\n    }>;\r\n    supportiveMessage: string;\r\n}\r\n\r\n// ============================================\r\n// CACHING\r\n// ============================================\r\n\r\nasync function getCachedResponse<T>(key: string): Promise<T | null> {\r\n    try {\r\n        const cached = await redis.get(key);\r\n        return cached ? JSON.parse(cached) : null;\r\n    } catch (error) {\r\n        console.error('Cache get error:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nasync function setCachedResponse(key: string, data: any): Promise<void> {\r\n    try {\r\n        await redis.setex(key, CACHE_TTL, JSON.stringify(data));\r\n    } catch (error) {\r\n        console.error('Cache set error:', error);\r\n    }\r\n}\r\n\r\nfunction generateCacheKey(type: string, input: any): string {\r\n    return `ai:${type}:${JSON.stringify(input)}`;\r\n}\r\n\r\n// ============================================\r\n// RATE LIMITING\r\n// ============================================\r\n\r\nasync function checkRateLimit(userId: string): Promise<boolean> {\r\n    const key = `ratelimit:${userId}:${new Date().toISOString().split('T')[0]}`;\r\n    const count = await redis.incr(key);\r\n\r\n    if (count === 1) {\r\n        await redis.expire(key, 86400); // 24 hours\r\n    }\r\n\r\n    return count <= MAX_REQUESTS_PER_DAY;\r\n}\r\n\r\n// ============================================\r\n// COST TRACKING\r\n// ============================================\r\n\r\nfunction calculateCost(tokens: number, model: string): number {\r\n    // GPT-4o-mini pricing: $0.150 / 1M input tokens, $0.600 / 1M output tokens\r\n    // Simplified: average $0.375 / 1M tokens\r\n    return (tokens / 1_000_000) * 0.375;\r\n}\r\n\r\nasync function logAIDecision(\r\n    userId: string,\r\n    habitId: string | null,\r\n    decisionType: string,\r\n    inputData: any,\r\n    aiResponse: any,\r\n    explanation: string | null,\r\n    tokensUsed: number\r\n) {\r\n    const cost = calculateCost(tokensUsed, MODEL);\r\n\r\n    await prisma.aIDecision.create({\r\n        data: {\r\n            userId,\r\n            habitId,\r\n            decisionType,\r\n            inputData,\r\n            aiResponse,\r\n            explanation,\r\n            tokensUsed,\r\n            costUsd: cost,\r\n            modelUsed: MODEL,\r\n        },\r\n    });\r\n}\r\n\r\n// ============================================\r\n// AI OPERATIONS\r\n// ============================================\r\n\r\nexport async function generateHabitPlan(\r\n    userId: string,\r\n    input: GeneratePlanInput\r\n): Promise<GeneratePlanOutput> {\r\n    // Check rate limit\r\n    const allowed = await checkRateLimit(userId);\r\n    if (!allowed) {\r\n        throw new Error('Daily AI request limit exceeded');\r\n    }\r\n\r\n    // Check cache\r\n    const cacheKey = generateCacheKey('generate-plan', input);\r\n    const cached = await getCachedResponse<GeneratePlanOutput>(cacheKey);\r\n    if (cached) return cached;\r\n\r\n    const prompt = `You are a supportive habit coach. Generate a micro-habit plan.\r\n\r\nInput:\r\n${JSON.stringify(input, null, 2)}\r\n\r\nReturn ONLY valid JSON matching this structure:\r\n{\r\n  \"habitTitle\": \"string\",\r\n  \"microSteps\": [{\"step\": \"string\", \"duration\": \"string\"}],\r\n  \"estimatedDifficulty\": number (1-10),\r\n  \"rationale\": \"string (one supportive sentence)\",\r\n  \"suggestedFrequency\": \"daily|weekly|custom\",\r\n  \"optimalTime\": \"morning|afternoon|evening|anytime\"\r\n}\r\n\r\nRules:\r\n- Start small (2-5 micro-steps)\r\n- Be specific and actionable\r\n- Match the coaching tone: ${input.coachingTone}\r\n- No guilt or shame language\r\n- Focus on consistency over intensity`;\r\n\r\n    const response = await openai.chat.completions.create({\r\n        model: MODEL,\r\n        messages: [{ role: 'user', content: prompt }],\r\n        temperature: 0.7,\r\n        response_format: { type: 'json_object' },\r\n    });\r\n\r\n    const result = JSON.parse(response.choices[0].message.content || '{}') as GeneratePlanOutput;\r\n    const tokensUsed = response.usage?.total_tokens || 0;\r\n\r\n    // Cache and log\r\n    await setCachedResponse(cacheKey, result);\r\n    await logAIDecision(userId, null, 'generate_plan', input, result, result.rationale, tokensUsed);\r\n\r\n    return result;\r\n}\r\n\r\nexport async function adjustDifficulty(\r\n    userId: string,\r\n    input: AdjustDifficultyInput\r\n): Promise<AdjustDifficultyOutput> {\r\n    // Rule-based fallback for simple cases\r\n    const { completionRate7d, consecutiveMisses } = input.recentPerformance;\r\n\r\n    if (consecutiveMisses < 3 && (completionRate7d > 0.8 || completionRate7d < 0.4)) {\r\n        return ruleBasedDifficultyAdjust(input);\r\n    }\r\n\r\n    // Check rate limit\r\n    const allowed = await checkRateLimit(userId);\r\n    if (!allowed) {\r\n        return ruleBasedDifficultyAdjust(input);\r\n    }\r\n\r\n    const prompt = `Analyze habit performance and suggest difficulty adjustment.\r\n\r\nInput:\r\n${JSON.stringify(input, null, 2)}\r\n\r\nReturn ONLY valid JSON:\r\n{\r\n  \"newDifficulty\": number (1-10),\r\n  \"adjustmentReason\": \"increase|decrease|maintain\",\r\n  \"explanation\": \"string (one supportive sentence)\",\r\n  \"recommendedChanges\": {\r\n    \"microSteps\": [{\"step\": \"string\", \"duration\": \"string\"}]\r\n  },\r\n  \"confidence\": number (0-1)\r\n}\r\n\r\nRules:\r\n- Adjust gradually (max Â±2 levels)\r\n- Prioritize recovery over perfection\r\n- Be supportive, never use guilt`;\r\n\r\n    const response = await openai.chat.completions.create({\r\n        model: MODEL,\r\n        messages: [{ role: 'user', content: prompt }],\r\n        temperature: 0.5,\r\n        response_format: { type: 'json_object' },\r\n    });\r\n\r\n    const result = JSON.parse(response.choices[0].message.content || '{}') as AdjustDifficultyOutput;\r\n    const tokensUsed = response.usage?.total_tokens || 0;\r\n\r\n    await logAIDecision(userId, input.habitId, 'adjust_difficulty', input, result, result.explanation, tokensUsed);\r\n\r\n    return result;\r\n}\r\n\r\nfunction ruleBasedDifficultyAdjust(input: AdjustDifficultyInput): AdjustDifficultyOutput {\r\n    const { completionRate7d } = input.recentPerformance;\r\n    const { currentDifficulty } = input;\r\n\r\n    if (completionRate7d < 0.5 && currentDifficulty > 1) {\r\n        return {\r\n            newDifficulty: Math.max(1, currentDifficulty - 1),\r\n            adjustmentReason: 'decrease',\r\n            explanation: \"Let's make this easier to rebuild your momentum.\",\r\n            confidence: 0.9,\r\n        };\r\n    }\r\n\r\n    if (completionRate7d > 0.85 && currentDifficulty < 10) {\r\n        return {\r\n            newDifficulty: currentDifficulty + 1,\r\n            adjustmentReason: 'increase',\r\n            explanation: \"You're crushing it! Ready for a bigger challenge?\",\r\n            confidence: 0.9,\r\n        };\r\n    }\r\n\r\n    return {\r\n        newDifficulty: currentDifficulty,\r\n        adjustmentReason: 'maintain',\r\n        explanation: 'Keep going! Your current level is working well.',\r\n        confidence: 1.0,\r\n    };\r\n}\r\n\r\nexport async function analyzeBurnout(\r\n    userId: string,\r\n    input: BurnoutAnalysisInput\r\n): Promise<BurnoutAnalysisOutput> {\r\n    // Check rate limit\r\n    const allowed = await checkRateLimit(userId);\r\n    if (!allowed) {\r\n        throw new Error('Daily AI request limit exceeded');\r\n    }\r\n\r\n    const prompt = `Analyze user's habit patterns for burnout signals.\r\n\r\nInput:\r\n${JSON.stringify(input, null, 2)}\r\n\r\nReturn ONLY valid JSON:\r\n{\r\n  \"burnoutDetected\": boolean,\r\n  \"severity\": \"none|low|medium|high\",\r\n  \"primaryCauses\": [\"string\"],\r\n  \"suggestedActions\": [{\r\n    \"action\": \"reduce_difficulty|pause_habit|add_recovery_day\",\r\n    \"habitIds\": [\"string\"],\r\n    \"newDifficulty\": number,\r\n    \"explanation\": \"string\"\r\n  }],\r\n  \"supportiveMessage\": \"string (empathetic, no guilt)\"\r\n}\r\n\r\nRules:\r\n- Be conservative (prefer false negatives to false positives)\r\n- Suggest gradual adjustments\r\n- Emphasize recovery and adaptation\r\n- Never blame the user`;\r\n\r\n    const response = await openai.chat.completions.create({\r\n        model: MODEL,\r\n        messages: [{ role: 'user', content: prompt }],\r\n        temperature: 0.6,\r\n        response_format: { type: 'json_object' },\r\n    });\r\n\r\n    const result = JSON.parse(response.choices[0].message.content || '{}') as BurnoutAnalysisOutput;\r\n    const tokensUsed = response.usage?.total_tokens || 0;\r\n\r\n    await logAIDecision(userId, null, 'burnout_analysis', input, result, result.supportiveMessage, tokensUsed);\r\n\r\n    return result;\r\n}\r\n\r\nexport async function generateInsightNarrative(\r\n    userId: string,\r\n    metrics: any\r\n): Promise<{ headline: string; insights: any[]; nextSteps: string[] }> {\r\n    const cacheKey = generateCacheKey('insights', metrics);\r\n    const cached = await getCachedResponse<any>(cacheKey);\r\n    if (cached) return cached;\r\n\r\n    const allowed = await checkRateLimit(userId);\r\n    if (!allowed) {\r\n        throw new Error('Daily AI request limit exceeded');\r\n    }\r\n\r\n    const prompt = `Generate personalized habit insights.\r\n\r\nMetrics:\r\n${JSON.stringify(metrics, null, 2)}\r\n\r\nReturn ONLY valid JSON:\r\n{\r\n  \"headline\": \"string (engaging, positive)\",\r\n  \"insights\": [{\r\n    \"type\": \"strength|opportunity|pattern\",\r\n    \"message\": \"string\"\r\n  }],\r\n  \"nextSteps\": [\"string\"]\r\n}\r\n\r\nRules:\r\n- Celebrate wins first\r\n- Frame challenges as opportunities\r\n- Be specific with data\r\n- Keep it actionable`;\r\n\r\n    const response = await openai.chat.completions.create({\r\n        model: MODEL,\r\n        messages: [{ role: 'user', content: prompt }],\r\n        temperature: 0.8,\r\n        response_format: { type: 'json_object' },\r\n    });\r\n\r\n    const result = JSON.parse(response.choices[0].message.content || '{}');\r\n    const tokensUsed = response.usage?.total_tokens || 0;\r\n\r\n    await setCachedResponse(cacheKey, result);\r\n    await logAIDecision(userId, null, 'generate_insights', metrics, result, null, tokensUsed);\r\n\r\n    return result;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\src\\services\\authService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":113,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2888,2891],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2888,2891],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import prisma from '../lib/prisma';\r\nimport { hashPassword, verifyPassword, generateToken } from '../lib/auth';\r\nimport { z } from 'zod';\r\n\r\nconst signupSchema = z.object({\r\n    email: z.string().email(),\r\n    password: z.string().min(8),\r\n    displayName: z.string().optional(),\r\n});\r\n\r\nconst loginSchema = z.object({\r\n    email: z.string().email(),\r\n    password: z.string(),\r\n});\r\n\r\nexport async function signup(data: z.infer<typeof signupSchema>) {\r\n    const validated = signupSchema.parse(data);\r\n\r\n    // Check if user exists\r\n    const existing = await prisma.user.findUnique({\r\n        where: { email: validated.email },\r\n    });\r\n\r\n    if (existing) {\r\n        throw new Error('User already exists');\r\n    }\r\n\r\n    // Create user\r\n    const passwordHash = await hashPassword(validated.password);\r\n    const user = await prisma.user.create({\r\n        data: {\r\n            email: validated.email,\r\n            passwordHash,\r\n            displayName: validated.displayName,\r\n        },\r\n    });\r\n\r\n    // Create default preferences\r\n    await prisma.userPreferences.create({\r\n        data: {\r\n            userId: user.id,\r\n        },\r\n    });\r\n\r\n    // Generate token\r\n    const token = generateToken({ userId: user.id, email: user.email });\r\n\r\n    return {\r\n        user: {\r\n            id: user.id,\r\n            email: user.email,\r\n            displayName: user.displayName,\r\n        },\r\n        token,\r\n    };\r\n}\r\n\r\nexport async function login(data: z.infer<typeof loginSchema>) {\r\n    const validated = loginSchema.parse(data);\r\n\r\n    // Find user\r\n    const user = await prisma.user.findUnique({\r\n        where: { email: validated.email },\r\n    });\r\n\r\n    if (!user) {\r\n        throw new Error('Invalid credentials');\r\n    }\r\n\r\n    // Verify password\r\n    const valid = await verifyPassword(validated.password, user.passwordHash);\r\n    if (!valid) {\r\n        throw new Error('Invalid credentials');\r\n    }\r\n\r\n    // Generate token\r\n    const token = generateToken({ userId: user.id, email: user.email });\r\n\r\n    return {\r\n        user: {\r\n            id: user.id,\r\n            email: user.email,\r\n            displayName: user.displayName,\r\n            onboardingCompleted: user.onboardingCompleted,\r\n        },\r\n        token,\r\n    };\r\n}\r\n\r\nexport async function getUserProfile(userId: string) {\r\n    const user = await prisma.user.findUnique({\r\n        where: { id: userId },\r\n        include: {\r\n            preferences: true,\r\n        },\r\n    });\r\n\r\n    if (!user) {\r\n        throw new Error('User not found');\r\n    }\r\n\r\n    return {\r\n        id: user.id,\r\n        email: user.email,\r\n        displayName: user.displayName,\r\n        timezone: user.timezone,\r\n        onboardingCompleted: user.onboardingCompleted,\r\n        coachingTone: user.coachingTone,\r\n        preferences: user.preferences,\r\n    };\r\n}\r\n\r\nexport async function updateUserProfile(userId: string, data: any) {\r\n    const user = await prisma.user.update({\r\n        where: { id: userId },\r\n        data: {\r\n            displayName: data.displayName,\r\n            timezone: data.timezone,\r\n            coachingTone: data.coachingTone,\r\n            onboardingCompleted: data.onboardingCompleted,\r\n        },\r\n    });\r\n\r\n    return user;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\src\\services\\habitService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":113,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3289,3292],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3289,3292],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":158,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4496,4499],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4496,4499],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used.","line":198,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":198,"endColumn":52}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import prisma from '../lib/prisma';\r\nimport { z } from 'zod';\r\nimport { generateHabitPlan } from './aiService';\r\n\r\nconst createHabitSchema = z.object({\r\n    title: z.string().min(1).max(200),\r\n    description: z.string().optional(),\r\n    category: z.string().optional(),\r\n    frequency: z.enum(['daily', 'weekly', 'custom']),\r\n    targetDays: z.array(z.number()).optional(),\r\n    timeOfDay: z.enum(['morning', 'afternoon', 'evening', 'anytime']).optional(),\r\n    useAI: z.boolean().default(true),\r\n    goal: z.string().optional(),\r\n    userContext: z.object({\r\n        experienceLevel: z.string().optional(),\r\n        availableTime: z.string().optional(),\r\n        constraints: z.array(z.string()).optional(),\r\n    }).optional(),\r\n});\r\n\r\nexport async function createHabit(userId: string, data: z.infer<typeof createHabitSchema>) {\r\n    const validated = createHabitSchema.parse(data);\r\n\r\n    let microSteps = null;\r\n    let aiRationale = null;\r\n    let estimatedDifficulty = 3;\r\n\r\n    // Generate AI plan if requested\r\n    if (validated.useAI && validated.goal) {\r\n        const user = await prisma.user.findUnique({ where: { id: userId } });\r\n\r\n        const aiPlan = await generateHabitPlan(userId, {\r\n            goal: validated.goal,\r\n            userContext: validated.userContext || {},\r\n            coachingTone: user?.coachingTone || 'supportive',\r\n        });\r\n\r\n        microSteps = aiPlan.microSteps;\r\n        aiRationale = aiPlan.rationale;\r\n        estimatedDifficulty = aiPlan.estimatedDifficulty;\r\n    }\r\n\r\n    // Create habit\r\n    const habit = await prisma.habit.create({\r\n        data: {\r\n            userId,\r\n            title: validated.title,\r\n            description: validated.description,\r\n            category: validated.category,\r\n            frequency: validated.frequency,\r\n            targetDays: validated.targetDays,\r\n            timeOfDay: validated.timeOfDay,\r\n            currentDifficulty: estimatedDifficulty,\r\n            baseDifficulty: estimatedDifficulty,\r\n            microSteps,\r\n            aiRationale,\r\n        },\r\n    });\r\n\r\n    // Create streak record\r\n    await prisma.streak.create({\r\n        data: {\r\n            habitId: habit.id,\r\n            userId,\r\n        },\r\n    });\r\n\r\n    return habit;\r\n}\r\n\r\nexport async function getHabits(userId: string, status: string = 'active') {\r\n    const habits = await prisma.habit.findMany({\r\n        where: {\r\n            userId,\r\n            status,\r\n        },\r\n        include: {\r\n            streak: true,\r\n            logs: {\r\n                take: 30,\r\n                orderBy: { completedAt: 'desc' },\r\n            },\r\n        },\r\n        orderBy: { createdAt: 'desc' },\r\n    });\r\n\r\n    return habits;\r\n}\r\n\r\nexport async function getHabitById(userId: string, habitId: string) {\r\n    const habit = await prisma.habit.findFirst({\r\n        where: {\r\n            id: habitId,\r\n            userId,\r\n        },\r\n        include: {\r\n            streak: true,\r\n            logs: {\r\n                take: 90,\r\n                orderBy: { completedAt: 'desc' },\r\n            },\r\n            fallbackHabit: true,\r\n        },\r\n    });\r\n\r\n    if (!habit) {\r\n        throw new Error('Habit not found');\r\n    }\r\n\r\n    return habit;\r\n}\r\n\r\nexport async function updateHabit(userId: string, habitId: string, data: any) {\r\n    // Verify ownership\r\n    const existing = await prisma.habit.findFirst({\r\n        where: { id: habitId, userId },\r\n    });\r\n\r\n    if (!existing) {\r\n        throw new Error('Habit not found');\r\n    }\r\n\r\n    const habit = await prisma.habit.update({\r\n        where: { id: habitId },\r\n        data: {\r\n            title: data.title,\r\n            description: data.description,\r\n            category: data.category,\r\n            frequency: data.frequency,\r\n            targetDays: data.targetDays,\r\n            timeOfDay: data.timeOfDay,\r\n            status: data.status,\r\n            lockedDifficulty: data.lockedDifficulty,\r\n            currentDifficulty: data.currentDifficulty,\r\n        },\r\n    });\r\n\r\n    return habit;\r\n}\r\n\r\nexport async function deleteHabit(userId: string, habitId: string) {\r\n    // Verify ownership\r\n    const existing = await prisma.habit.findFirst({\r\n        where: { id: habitId, userId },\r\n    });\r\n\r\n    if (!existing) {\r\n        throw new Error('Habit not found');\r\n    }\r\n\r\n    await prisma.habit.delete({\r\n        where: { id: habitId },\r\n    });\r\n\r\n    return { success: true };\r\n}\r\n\r\nexport async function logHabitCompletion(userId: string, habitId: string, data: any) {\r\n    // Verify habit exists and belongs to user\r\n    const habit = await prisma.habit.findFirst({\r\n        where: { id: habitId, userId },\r\n    });\r\n\r\n    if (!habit) {\r\n        throw new Error('Habit not found');\r\n    }\r\n\r\n    // Create log\r\n    const log = await prisma.habitLog.create({\r\n        data: {\r\n            habitId,\r\n            userId,\r\n            completedAt: data.completedAt ? new Date(data.completedAt) : new Date(),\r\n            difficultyAtCompletion: habit.currentDifficulty,\r\n            energyLevel: data.energyLevel,\r\n            timeAvailable: data.timeAvailable,\r\n            dayType: data.dayType,\r\n            feltTooEasy: data.feltTooEasy,\r\n            feltTooHard: data.feltTooHard,\r\n            notes: data.notes,\r\n            synced: true,\r\n            clientCreatedAt: data.clientCreatedAt ? new Date(data.clientCreatedAt) : null,\r\n        },\r\n    });\r\n\r\n    // Update habit's last completed timestamp\r\n    await prisma.habit.update({\r\n        where: { id: habitId },\r\n        data: { lastCompletedAt: log.completedAt },\r\n    });\r\n\r\n    // Update streak (simplified - should be done in background job)\r\n    await updateStreak(habitId, userId);\r\n\r\n    return log;\r\n}\r\n\r\nasync function updateStreak(habitId: string, userId: string) {\r\n    const habit = await prisma.habit.findUnique({\r\n        where: { id: habitId },\r\n        include: {\r\n            logs: {\r\n                orderBy: { completedAt: 'desc' },\r\n                take: 30,\r\n            },\r\n            streak: true,\r\n        },\r\n    });\r\n\r\n    if (!habit || !habit.streak) return;\r\n\r\n    // Calculate current streak\r\n    let currentStreak = 0;\r\n    const today = new Date();\r\n    today.setHours(0, 0, 0, 0);\r\n\r\n    // Simple streak calculation (can be enhanced)\r\n    const sortedLogs = habit.logs.sort((a, b) => b.completedAt.getTime() - a.completedAt.getTime());\r\n\r\n    for (let i = 0; i < sortedLogs.length; i++) {\r\n        const logDate = new Date(sortedLogs[i].completedAt);\r\n        logDate.setHours(0, 0, 0, 0);\r\n\r\n        const daysDiff = Math.floor((today.getTime() - logDate.getTime()) / (1000 * 60 * 60 * 24));\r\n\r\n        if (daysDiff === i) {\r\n            currentStreak++;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    await prisma.streak.update({\r\n        where: { habitId },\r\n        data: {\r\n            currentStreak,\r\n            longestStreak: Math.max(habit.streak.longestStreak, currentStreak),\r\n        },\r\n    });\r\n}\r\n\r\nexport async function getHabitStats(userId: string, habitId: string, days: number = 30) {\r\n    const habit = await prisma.habit.findFirst({\r\n        where: { id: habitId, userId },\r\n        include: {\r\n            logs: {\r\n                where: {\r\n                    completedAt: {\r\n                        gte: new Date(Date.now() - days * 24 * 60 * 60 * 1000),\r\n                    },\r\n                },\r\n                orderBy: { completedAt: 'desc' },\r\n            },\r\n            streak: true,\r\n        },\r\n    });\r\n\r\n    if (!habit) {\r\n        throw new Error('Habit not found');\r\n    }\r\n\r\n    const totalDays = days;\r\n    const completedDays = habit.logs.length;\r\n    const completionRate = completedDays / totalDays;\r\n\r\n    return {\r\n        habitId: habit.id,\r\n        title: habit.title,\r\n        currentStreak: habit.streak?.currentStreak || 0,\r\n        longestStreak: habit.streak?.longestStreak || 0,\r\n        completionRate,\r\n        totalCompletions: completedDays,\r\n        currentDifficulty: habit.currentDifficulty,\r\n        recentLogs: habit.logs.slice(0, 7),\r\n    };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\src\\services\\syncService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":7,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[161,164],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[161,164],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[387,390],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[387,390],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":17,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[409,412],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[409,412],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[432,435],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[432,435],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":109,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2864,2867],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2864,2867],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'serverUpdatedAt' is assigned a value but never used.","line":155,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":155,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":198,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5283,5286],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5283,5286],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'clientUpdatedAt' is defined but never used.","line":199,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":199,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":235,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":235,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6519,6522],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6519,6522],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":235,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":235,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6536,6539],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6536,6539],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":235,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":235,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6542,6545],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6542,6545],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import prisma from '../lib/prisma';\r\n\r\ninterface SyncChange {\r\n    table: string;\r\n    recordId: string;\r\n    action: 'create' | 'update' | 'delete';\r\n    data: any;\r\n    updatedAt: string;\r\n    clientVersion?: number;\r\n}\r\n\r\ninterface ConflictResolution {\r\n    recordId: string;\r\n    table: string;\r\n    strategy: 'server_wins' | 'client_wins' | 'merged' | 'keep_both';\r\n    serverData: any;\r\n    clientData: any;\r\n    mergedData?: any;\r\n}\r\n\r\nexport async function pullChanges(userId: string, lastSyncTimestamp?: string) {\r\n    const since = lastSyncTimestamp ? new Date(lastSyncTimestamp) : new Date(0);\r\n\r\n    // Fetch all changes since last sync\r\n    const [habits, habitLogs, streaks, notifications] = await Promise.all([\r\n        prisma.habit.findMany({\r\n            where: {\r\n                userId,\r\n                updatedAt: { gt: since },\r\n            },\r\n        }),\r\n        prisma.habitLog.findMany({\r\n            where: {\r\n                userId,\r\n                completedAt: { gt: since },\r\n            },\r\n        }),\r\n        prisma.streak.findMany({\r\n            where: {\r\n                userId,\r\n                updatedAt: { gt: since },\r\n            },\r\n        }),\r\n        prisma.notification.findMany({\r\n            where: {\r\n                userId,\r\n                scheduledFor: { gt: since },\r\n            },\r\n        }),\r\n    ]);\r\n\r\n    return {\r\n        habits,\r\n        habitLogs,\r\n        streaks,\r\n        notifications,\r\n        timestamp: new Date().toISOString(),\r\n    };\r\n}\r\n\r\nexport async function pushChanges(userId: string, changes: SyncChange[]) {\r\n    const conflicts: ConflictResolution[] = [];\r\n    const applied: string[] = [];\r\n\r\n    for (const change of changes) {\r\n        try {\r\n            const conflict = await applyChange(userId, change);\r\n\r\n            if (conflict) {\r\n                conflicts.push(conflict);\r\n            } else {\r\n                applied.push(change.recordId);\r\n            }\r\n        } catch (error) {\r\n            console.error(`Error applying change for ${change.recordId}:`, error);\r\n        }\r\n    }\r\n\r\n    return {\r\n        applied,\r\n        conflicts,\r\n        timestamp: new Date().toISOString(),\r\n    };\r\n}\r\n\r\nasync function applyChange(\r\n    userId: string,\r\n    change: SyncChange\r\n): Promise<ConflictResolution | null> {\r\n    const { table, recordId, action, data, updatedAt } = change;\r\n\r\n    // Handle different tables\r\n    switch (table) {\r\n        case 'habits':\r\n            return await applyHabitChange(userId, recordId, action, data, updatedAt);\r\n\r\n        case 'habit_logs':\r\n            return await applyHabitLogChange(userId, recordId, action, data, updatedAt);\r\n\r\n        default:\r\n            throw new Error(`Unsupported table: ${table}`);\r\n    }\r\n}\r\n\r\nasync function applyHabitChange(\r\n    userId: string,\r\n    recordId: string,\r\n    action: string,\r\n    data: any,\r\n    clientUpdatedAt: string\r\n): Promise<ConflictResolution | null> {\r\n    if (action === 'create') {\r\n        // Check if already exists\r\n        const existing = await prisma.habit.findUnique({ where: { id: recordId } });\r\n\r\n        if (existing) {\r\n            // Conflict: client thinks it's new, but server has it\r\n            return {\r\n                recordId,\r\n                table: 'habits',\r\n                strategy: 'server_wins',\r\n                serverData: existing,\r\n                clientData: data,\r\n            };\r\n        }\r\n\r\n        // Create new habit\r\n        await prisma.habit.create({\r\n            data: {\r\n                id: recordId,\r\n                userId,\r\n                ...data,\r\n            },\r\n        });\r\n\r\n        return null;\r\n    }\r\n\r\n    if (action === 'update') {\r\n        const serverRecord = await prisma.habit.findUnique({ where: { id: recordId } });\r\n\r\n        if (!serverRecord) {\r\n            // Record doesn't exist on server, treat as create\r\n            await prisma.habit.create({\r\n                data: {\r\n                    id: recordId,\r\n                    userId,\r\n                    ...data,\r\n                },\r\n            });\r\n            return null;\r\n        }\r\n\r\n        // Check for conflict\r\n        const serverUpdatedAt = serverRecord.updatedAt.toISOString();\r\n        const clientUpdatedAtDate = new Date(clientUpdatedAt);\r\n\r\n        if (serverRecord.updatedAt > clientUpdatedAtDate) {\r\n            // Server is newer - conflict!\r\n            const merged = mergeHabitData(serverRecord, data);\r\n\r\n            await prisma.habit.update({\r\n                where: { id: recordId },\r\n                data: merged,\r\n            });\r\n\r\n            return {\r\n                recordId,\r\n                table: 'habits',\r\n                strategy: 'merged',\r\n                serverData: serverRecord,\r\n                clientData: data,\r\n                mergedData: merged,\r\n            };\r\n        }\r\n\r\n        // Client is newer, apply update\r\n        await prisma.habit.update({\r\n            where: { id: recordId },\r\n            data,\r\n        });\r\n\r\n        return null;\r\n    }\r\n\r\n    if (action === 'delete') {\r\n        await prisma.habit.delete({ where: { id: recordId } });\r\n        return null;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nasync function applyHabitLogChange(\r\n    userId: string,\r\n    recordId: string,\r\n    action: string,\r\n    data: any,\r\n    clientUpdatedAt: string\r\n): Promise<ConflictResolution | null> {\r\n    if (action === 'create') {\r\n        // Habit logs are append-only, check for duplicates\r\n        const existing = await prisma.habitLog.findUnique({ where: { id: recordId } });\r\n\r\n        if (existing) {\r\n            // Already exists, no conflict (idempotent)\r\n            return null;\r\n        }\r\n\r\n        await prisma.habitLog.create({\r\n            data: {\r\n                id: recordId,\r\n                userId,\r\n                habitId: data.habitId,\r\n                completedAt: new Date(data.completedAt),\r\n                difficultyAtCompletion: data.difficultyAtCompletion,\r\n                energyLevel: data.energyLevel,\r\n                timeAvailable: data.timeAvailable,\r\n                dayType: data.dayType,\r\n                feltTooEasy: data.feltTooEasy,\r\n                feltTooHard: data.feltTooHard,\r\n                notes: data.notes,\r\n                synced: true,\r\n                clientCreatedAt: data.clientCreatedAt ? new Date(data.clientCreatedAt) : null,\r\n            },\r\n        });\r\n\r\n        return null;\r\n    }\r\n\r\n    // Logs are typically not updated or deleted\r\n    return null;\r\n}\r\n\r\nfunction mergeHabitData(serverData: any, clientData: any): any {\r\n    // Merge strategy: client wins for user-editable fields, server wins for AI fields\r\n    return {\r\n        title: clientData.title ?? serverData.title,\r\n        description: clientData.description ?? serverData.description,\r\n        category: clientData.category ?? serverData.category,\r\n        frequency: clientData.frequency ?? serverData.frequency,\r\n        targetDays: clientData.targetDays ?? serverData.targetDays,\r\n        timeOfDay: clientData.timeOfDay ?? serverData.timeOfDay,\r\n        status: clientData.status ?? serverData.status,\r\n        lockedDifficulty: clientData.lockedDifficulty ?? serverData.lockedDifficulty,\r\n\r\n        // Server wins for AI-managed fields\r\n        currentDifficulty: serverData.currentDifficulty,\r\n        microSteps: serverData.microSteps,\r\n        aiRationale: serverData.aiRationale,\r\n\r\n        updatedAt: new Date(),\r\n    };\r\n}\r\n\r\nexport async function getConflicts(userId: string) {\r\n    // Get unresolved conflicts from sync metadata\r\n    const conflicts = await prisma.syncMetadata.findMany({\r\n        where: {\r\n            userId,\r\n            conflictResolution: { not: null },\r\n        },\r\n        orderBy: { lastSyncedAt: 'desc' },\r\n        take: 50,\r\n    });\r\n\r\n    return conflicts;\r\n}\r\n\r\nexport async function resolveConflict(\r\n    userId: string,\r\n    recordId: string,\r\n    resolution: 'accept_server' | 'accept_client' | 'accept_merged'\r\n) {\r\n    // Update sync metadata\r\n    await prisma.syncMetadata.updateMany({\r\n        where: {\r\n            userId,\r\n            recordId,\r\n        },\r\n        data: {\r\n            conflictResolution: resolution === 'accept_server' ? 'server_wins' :\r\n                resolution === 'accept_client' ? 'client_wins' : 'merged',\r\n            lastSyncedAt: new Date(),\r\n        },\r\n    });\r\n\r\n    return { success: true };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\src\\workers\\burnoutWorker.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'severity' is assigned a value but never used.","line":92,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":92,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":134,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4098,4101],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4098,4101],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":135,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4165,4168],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4165,4168],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Worker, Job } from 'bullmq';\r\nimport { connection } from '../lib/queue';\r\nimport prisma from '../lib/prisma';\r\nimport { analyzeBurnout } from '../services/aiService';\r\n\r\nexport function createBurnoutWorker() {\r\n    return new Worker(\r\n        'burnout',\r\n        async (job: Job) => {\r\n            console.log(`Processing burnout detection job: ${job.id}`);\r\n\r\n            // Get all active users\r\n            const users = await prisma.user.findMany({\r\n                where: { onboardingCompleted: true },\r\n                select: { id: true },\r\n            });\r\n\r\n            for (const user of users) {\r\n                try {\r\n                    await detectUserBurnout(user.id);\r\n                } catch (error) {\r\n                    console.error(`Error detecting burnout for user ${user.id}:`, error);\r\n                }\r\n            }\r\n\r\n            return { processed: users.length };\r\n        },\r\n        { connection }\r\n    );\r\n}\r\n\r\nasync function detectUserBurnout(userId: string) {\r\n    // Get user's active habits with recent logs\r\n    const habits = await prisma.habit.findMany({\r\n        where: {\r\n            userId,\r\n            status: 'active',\r\n        },\r\n        include: {\r\n            logs: {\r\n                where: {\r\n                    completedAt: {\r\n                        gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // Last 30 days\r\n                    },\r\n                },\r\n                orderBy: { completedAt: 'desc' },\r\n            },\r\n        },\r\n    });\r\n\r\n    if (habits.length === 0) return;\r\n\r\n    // Calculate metrics for each habit\r\n    const habitsSummary = habits.map((habit) => {\r\n        const logs7d = habit.logs.filter(\r\n            (log) => log.completedAt >= new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)\r\n        );\r\n        const logs30d = habit.logs;\r\n\r\n        const completionRate7d = logs7d.length / 7;\r\n        const completionRate30d = logs30d.length / 30;\r\n\r\n        const recentFeedback = logs7d\r\n            .filter((log) => log.feltTooHard)\r\n            .map(() => 'too_hard');\r\n\r\n        return {\r\n            habitId: habit.id,\r\n            title: habit.title,\r\n            completionRate30d,\r\n            completionRate7d,\r\n            difficulty: habit.currentDifficulty,\r\n            recentFeedback,\r\n        };\r\n    });\r\n\r\n    // Rule-based detection first\r\n    let burnoutDetected = false;\r\n    let severity: 'none' | 'low' | 'medium' | 'high' = 'none';\r\n\r\n    for (const habit of habitsSummary) {\r\n        const drop = habit.completionRate30d - habit.completionRate7d;\r\n\r\n        if (drop > 0.3) {\r\n            burnoutDetected = true;\r\n            severity = drop > 0.5 ? 'high' : 'medium';\r\n            break;\r\n        }\r\n\r\n        if (habit.recentFeedback.length >= 3) {\r\n            burnoutDetected = true;\r\n            severity = 'medium';\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!burnoutDetected) return;\r\n\r\n    // Check if we already have an unresolved signal\r\n    const existingSignal = await prisma.burnoutSignal.findFirst({\r\n        where: {\r\n            userId,\r\n            resolved: false,\r\n        },\r\n    });\r\n\r\n    if (existingSignal) return; // Don't create duplicate signals\r\n\r\n    // Get AI analysis\r\n    const avgCompletionRate =\r\n        habitsSummary.reduce((sum, h) => sum + h.completionRate30d, 0) / habitsSummary.length;\r\n\r\n    const aiAnalysis = await analyzeBurnout(userId, {\r\n        userId,\r\n        habitsSummary,\r\n        overallMetrics: {\r\n            totalActiveHabits: habits.length,\r\n            avgCompletionRate,\r\n            trend: 'declining',\r\n        },\r\n    });\r\n\r\n    // Create burnout signal\r\n    await prisma.burnoutSignal.create({\r\n        data: {\r\n            userId,\r\n            severity: aiAnalysis.severity,\r\n            completionRateDrop: habitsSummary[0]?.completionRate30d - habitsSummary[0]?.completionRate7d,\r\n            consecutiveMisses: 0,\r\n            difficultyComplaints: habitsSummary.reduce(\r\n                (sum, h) => sum + h.recentFeedback.length,\r\n                0\r\n            ),\r\n            aiAnalysis: aiAnalysis as any,\r\n            suggestedActions: aiAnalysis.suggestedActions as any,\r\n        },\r\n    });\r\n\r\n    console.log(`Burnout detected for user ${userId} - Severity: ${aiAnalysis.severity}`);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\src\\workers\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\Gemini\\Mobile Apps\\habitforge_native\\habitforge-backend\\src\\workers\\reminderWorker.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'format' is defined but never used.","line":4,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'parseISO' is defined but never used.","line":4,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":36},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":62,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2070,2073],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2070,2073],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":139,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4700,4703],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4700,4703],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Worker, Job } from 'bullmq';\r\nimport { connection } from '../lib/queue';\r\nimport prisma from '../lib/prisma';\r\nimport { addHours, format, parseISO } from 'date-fns';\r\n\r\nexport function createReminderWorker() {\r\n    return new Worker(\r\n        'reminders',\r\n        async (job: Job) => {\r\n            console.log(`Processing reminders job: ${job.id}`);\r\n\r\n            const now = new Date();\r\n            const upcoming = addHours(now, 1); // Next hour\r\n\r\n            // Find pending notifications scheduled for the next hour\r\n            const notifications = await prisma.notification.findMany({\r\n                where: {\r\n                    status: 'pending',\r\n                    scheduledFor: {\r\n                        gte: now,\r\n                        lte: upcoming,\r\n                    },\r\n                },\r\n                include: {\r\n                    user: {\r\n                        include: {\r\n                            preferences: true,\r\n                        },\r\n                    },\r\n                    habit: true,\r\n                },\r\n            });\r\n\r\n            for (const notification of notifications) {\r\n                try {\r\n                    await sendNotification(notification);\r\n\r\n                    // Mark as sent\r\n                    await prisma.notification.update({\r\n                        where: { id: notification.id },\r\n                        data: {\r\n                            status: 'sent',\r\n                            sentAt: new Date(),\r\n                        },\r\n                    });\r\n                } catch (error) {\r\n                    console.error(`Error sending notification ${notification.id}:`, error);\r\n\r\n                    await prisma.notification.update({\r\n                        where: { id: notification.id },\r\n                        data: { status: 'failed' },\r\n                    });\r\n                }\r\n            }\r\n\r\n            return { sent: notifications.length };\r\n        },\r\n        { connection }\r\n    );\r\n}\r\n\r\nasync function sendNotification(notification: any) {\r\n    // Check quiet hours\r\n    if (notification.user.preferences) {\r\n        const { quietHoursStart, quietHoursEnd } = notification.user.preferences;\r\n\r\n        if (quietHoursStart && quietHoursEnd) {\r\n            const now = new Date();\r\n            const currentHour = now.getHours();\r\n            const startHour = parseInt(quietHoursStart.split(':')[0]);\r\n            const endHour = parseInt(quietHoursEnd.split(':')[0]);\r\n\r\n            if (currentHour >= startHour && currentHour < endHour) {\r\n                console.log(`Skipping notification during quiet hours for user ${notification.userId}`);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    // In production, this would integrate with Expo Push Notifications\r\n    // For now, we'll just log it\r\n    console.log(`ð± Sending notification to user ${notification.userId}:`);\r\n    console.log(`   Title: ${notification.title}`);\r\n    console.log(`   Body: ${notification.body}`);\r\n    console.log(`   Type: ${notification.type}`);\r\n\r\n    // TODO: Integrate with Expo Push Notifications\r\n    // const message = {\r\n    //   to: notification.user.pushToken,\r\n    //   sound: 'default',\r\n    //   title: notification.title,\r\n    //   body: notification.body,\r\n    //   data: { habitId: notification.habitId, type: notification.type },\r\n    // };\r\n    // await expo.sendPushNotificationsAsync([message]);\r\n}\r\n\r\nexport async function scheduleHabitReminders(habitId: string) {\r\n    const habit = await prisma.habit.findUnique({\r\n        where: { id: habitId },\r\n        include: {\r\n            user: {\r\n                include: {\r\n                    preferences: true,\r\n                },\r\n            },\r\n            logs: {\r\n                take: 30,\r\n                orderBy: { completedAt: 'desc' },\r\n            },\r\n        },\r\n    });\r\n\r\n    if (!habit || !habit.user.preferences?.remindersEnabled) return;\r\n\r\n    // Find optimal time based on past completions\r\n    const optimalHour = findOptimalTime(habit.logs, habit.timeOfDay);\r\n\r\n    // Schedule for tomorrow\r\n    const tomorrow = new Date();\r\n    tomorrow.setDate(tomorrow.getDate() + 1);\r\n    tomorrow.setHours(optimalHour, 0, 0, 0);\r\n\r\n    // Create notification\r\n    await prisma.notification.create({\r\n        data: {\r\n            userId: habit.userId,\r\n            habitId: habit.id,\r\n            type: 'reminder',\r\n            title: habit.title,\r\n            body: `Time to ${habit.title.toLowerCase()}! You've got this ðª`,\r\n            scheduledFor: tomorrow,\r\n            optimalTime: true,\r\n            contextAware: true,\r\n        },\r\n    });\r\n}\r\n\r\nfunction findOptimalTime(logs: any[], preferredTime?: string | null): number {\r\n    if (logs.length === 0) {\r\n        // Default based on preference\r\n        return getHourFromTimeOfDay(preferredTime);\r\n    }\r\n\r\n    // Find most common completion hour\r\n    const hours = logs.map((log) => new Date(log.completedAt).getHours());\r\n    const hourCounts = hours.reduce((acc, hour) => {\r\n        acc[hour] = (acc[hour] || 0) + 1;\r\n        return acc;\r\n    }, {} as Record<number, number>);\r\n\r\n    const mostCommonHour = Object.entries(hourCounts).reduce((a, b) =>\r\n        a[1] > b[1] ? a : b\r\n    )[0];\r\n\r\n    return parseInt(mostCommonHour);\r\n}\r\n\r\nfunction getHourFromTimeOfDay(timeOfDay?: string | null): number {\r\n    switch (timeOfDay) {\r\n        case 'morning':\r\n            return 9;\r\n        case 'afternoon':\r\n            return 14;\r\n        case 'evening':\r\n            return 19;\r\n        default:\r\n            return 10;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]}]